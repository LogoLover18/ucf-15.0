#!/usr/bin/perl
##############################################################################
#
# Script for munging Unicode character data into a form suitable for UCF
#
# Uses local copies of:
#
#   http://www.unicode.org/Public/UCD/latest/ucdxml/ucd.nounihan.grouped.zip
#   http://www.unicode.org/Public/UCD/latest/ucdxml/ucd.unihan.grouped.zip
#
# Use --download option to get these files.
#
# Use --help option for more info.
#

use 5.014;
use strict;
use warnings;
use autodie;

use Pod::Usage;
use Getopt::Long  qw(GetOptions);
use LWP::Simple   qw(mirror RC_OK RC_NOT_MODIFIED);
use Archive::Zip  qw(:ERROR_CODES :CONSTANTS);
use Archive::Zip::MemberRead qw();

use FindBin;
use XML::SAX::ParserFactory;

my $url_latest_source_dir = 'http://www.unicode.org/Public/UCD/latest/ucdxml';
my $url_pdf_base          = 'http://www.unicode.org/charts/PDF';

my $local_data_dir        = $FindBin::Bin . '/unicode-source-data';

my $source_file_nounihan  = 'ucd.nounihan.grouped.zip';
my $source_file_all       = 'ucd.all.grouped.zip';

my $output_file_nounihan  = $FindBin::Bin . '/htdocs/char-data-nounihan.txt';
my $output_file_all       = $FindBin::Bin . '/htdocs/char-data-all.txt';


# Handle command-line arguments

my(%opt, %args);

if(!GetOptions(\%opt,
    'download|d',
    'char|c=s',
    'help|?',
)) {
    pod2usage(-exitval => 1,  -verbose => 0);
}

pod2usage(-exitstatus => 0, -verbose => 2) if $opt{help};

if($opt{char}) {
    $args{char} = uc($opt{char});
}
elsif($opt{attr}) {
    $args{attr} = $opt{attr};
}


translate_data($source_file_nounihan, $output_file_nounihan);

exit;

sub translate_data {
    my($zip_file, $output_filename) = @_;

    my $xml_ref = unzip_xml($zip_file);

    if(!%args) {
        print "Writing $output_filename\n";
        open my $out, '>', $output_filename;
        $args{out_fh} = $out;
    }
    $args{url_pdf_base} = $url_pdf_base;

    my $handler = UCFHandler->new(%args);
    my $parser  = XML::SAX::ParserFactory->parser(Handler => $handler);

    $parser->parse_string($$xml_ref);

    if($args{out_fh}) {
        append_html_entities($args{out_fh});
        close($args{out_fh});
        make_gzip_version($output_filename);
    }
}


sub unzip_xml {
    my($zip_file) = @_;

    my $local_zip_name  = get_zip_file($zip_file);

    my $zip = Archive::Zip->new();
    if($zip->read($local_zip_name) != AZ_OK) {
        die "Error reading $local_zip_name";
    }
    my @members = $zip->membersMatching('[.]xml$');
    if(@members == 0) {
        die "Can't find an XML file in $local_zip_name";
    }
    elsif(@members > 1) {
        die "Can't identify the correct XML file in $local_zip_name";
    }

    my($xml_member) = @members;
    print "Unzipping " . $xml_member->fileName . "\n";
    my $fh = $xml_member->readFileHandle;
    my $buffer;
    my $result = $fh->read($buffer, $xml_member->uncompressedSize);
    return \$buffer;
}


sub get_zip_file {
    my($zip_file) = @_;
    my $url             = $url_latest_source_dir . '/' . $zip_file;
    my $local_zip_name  = $local_data_dir        . '/' . $zip_file;

    if($opt{download}) {
        print "Downloading\nFrom: $url\nTo:   $local_zip_name\n";
        my $rc = mirror($url, $local_zip_name);
        if($rc == RC_NOT_MODIFIED) {
            print "Local copy already up to date.\n";
        }
        elsif($rc != RC_OK) {
            die "Download of $url failed: status = $rc";
        }
    }

    if(! -e $local_zip_name) {
        my $message = "File does not exist:\n  $local_zip_name\n";
        $message .= "Use --download to get the file\n";
        die $message;
    }

    return $local_zip_name;
}


sub append_html_entities {
    my($out) = @_;

    print $out "&amp\t0026\n";
    print $out "&lt\t003C\n";
    foreach my $dtd_file (sort glob("$local_data_dir/*.ent")) {
        open my $fh, '<', $dtd_file or die "open($dtd_file): $!";
        while(<$fh>) {
            if(my($name, $code) = $_ =~ m{<!ENTITY\s+(\w+)\s+"&#(\d+);">}) {
                $code = sprintf('%04X', $code);
                print $out "&$name\t$code\n";
            }
        }
    }

}


sub make_gzip_version {
    my($base_file) = @_;
    my $gz_file = $base_file . '.gz';

    print "Compressing to $gz_file\n";
    system("gzip --best < $base_file > $gz_file");
}

package UCFHandler;

use Data::Dumper;

sub new {
    my $class = shift;
    return bless {
        @_,
        last_code_point => 0,
    }, $class;
}

sub url_pdf_base {
    return shift->{url_pdf_base};
}

sub last_code_point {
    my $self = shift;
    $self->{last_code_point} = shift if @_;
    return $self->{last_code_point};
}

sub group_name_template {
    my $self = shift;
    $self->{group_name_template} = shift if @_;
    return $self->{group_name_template};
}

sub group_is_control_char {
    my $self = shift;
    $self->{group_is_control_char} = shift if @_;
    return $self->{group_is_control_char};
}

sub is_control_char {
    my $self = shift;
    if(my $attr = $self->char_attr) {
        if(my $gc = $attr->{gc}) {
            return $gc eq 'Cc';
        }
    }
    return $self->group_is_control_char;
}

sub char_attr {
    my $self = shift;
    $self->{char_attr} = shift if @_;
    return $self->{char_attr};
}

sub add_alias {
    my $self = shift;
    my $attr = $self->char_attr || return;
    my $aliases = $attr->{aliases};
    my $new = shift // return;
    return if $new eq '';
    foreach my $name ($attr->{name}, @$aliases) {
        return if $name eq $new;
        my $no_with = $name =~ s/ WITH / /r;
        return if $no_with eq $new;
    }
    push @$aliases, $new;
}

sub _delegate {
    my($self, $event, $data) = @_;

    my $name = $data->{LocalName};
    $name =~ s/-/_/g;
    my $method = $event . '_' . $name;
    if($self->can($method)) {
        $self->$method($data);
    }
}

sub _attr {
    my($self, $data) = @_;
    return {
        map { $_->{LocalName} => $_->{Value} }
            values %{ $data->{Attributes} }
    };
}

sub start_element {
    my($self, $data) = @_;
    return $self->_delegate('start_element', $data);
}

sub end_element {
    my($self, $data) = @_;
    return $self->_delegate('end_element', $data);
}

sub start_element_group {
    my($self, $data) = @_;
    my $attr = $self->_attr($data);
    $self->group_is_control_char(($attr->{gc} // '') eq 'Cc' ? 1 : 0);
    my $group_name_template;
    if(my $name = $attr->{na}) {
        if($name =~ s/#/%s/) {
            $group_name_template = $name;
        }
    }
    $self->group_name_template($group_name_template);
}

sub start_element_char {
    my($self, $data) = @_;
    my $attr = $self->_attr($data);
    $attr->{aliases} = [];
    $self->char_attr($attr);
    if($self->is_control_char) {
        $attr->{name} = '<control>';
        $self->add_alias($attr->{na});
    }
    else {
        $attr->{name} = $attr->{na} // $attr->{na1};
        if(!$attr->{name} && $attr->{cp}) {
            if(my $tmpl = $self->group_name_template) {
                $attr->{name} = sprintf($tmpl, $attr->{cp});
            }
        }
    }
    return unless $attr->{name};
    $self->add_alias($attr->{na1});
    $attr->{is_control} = $self->is_control_char ? 'Yes' : 'No';
}

sub start_element_name_alias {
    my($self, $data) = @_;
    my $attr = $self->_attr($data);
    my $alias = $attr->{alias} // return;
    if(my $type = $attr->{type}) {
        if(lc($type) eq 'correction') {
            $alias .= ' (correction)';
        }
    }
    $self->add_alias($alias);
}

sub end_element_char {
    my($self, $data) = @_;
    my $attr = $self->char_attr;
    return unless $attr->{cp};
    return unless $attr->{name};
    $self->add_unofficial_aliases;
    my $cp   = $attr->{cp};
    my $dcp  = hex($cp);
    my $name = $attr->{name};
    my $aliases = '';
    my $offset = $dcp - $self->last_code_point;
    $offset = '' if $offset == 1;
    if(@{ $attr->{aliases} }) {
        $aliases = "\t" . join('; ', @{ $attr->{aliases} });
    }
    if(my $out = $self->{out_fh}) {
        print $out "$offset\t$name$aliases\n";
    }
    elsif(my $target = $self->{char}) {
        return unless $attr->{cp} eq $target;
        print "$cp\t$name$aliases\n";
        print dump_attr($attr), "\n";
        exit;
    }
    $self->last_code_point($dcp);
}

sub start_element_block {
    my($self, $data) = @_;
    my $attr = $self->_attr($data);
    my $first = $attr->{'first-cp'} or return;
    my $last = $attr->{'last-cp'} or return;
    my $name = $attr->{'name'} or return;
    my $file = "U${first}.pdf";
    my $url = $self->url_pdf_base . '/' . $file;
    if(my $out = $self->{out_fh}) {
        print $out "[$first\t$last\t$name\t$file\t$url\n";
    }
}

sub add_unofficial_aliases {
    my($self) = @_;
    my $attr = $self->char_attr;
    my $aliases = $attr->{aliases};
    my $all_names = join(' ', $attr->{name}, @$aliases);

    if(
            $all_names =~ /\bDIAERESIS\b/i
        and $all_names !~ /\bUMLAUT\b/i
        and $all_names !~ /\bGREEK\b/i
    ) {
        foreach ($attr->{name}, @$aliases) {
            s/\b(DIAERESIS)\b/$1 (OR UMLAUT)/i && last;
        }
    }
}

sub dump_attr {
    my($attr) = @_;

    return join "\n",
        $attr->{cp} ? $attr->{cp} : (),
        map { "  $_: $attr->{$_}" }
        grep { $_ ne 'cp' } sort keys %$attr;
}

1;

__END__

=head1 NAME

make-data-file - generate data file for Unicode Character Finder

=head1 SYNOPSIS

  make-data-file [options] <files>

  Options:

   --download     get a fresh copy of source data if required
   --char <num>   hex codepoint number of character to be dumped
   --help         detailed help message

=head1 DESCRIPTION

This script generates the data file used by the Unicode Character Finder.
It processes the XML Unicode Character Data file and produces a plain text
(tab delimited) data file as output.

=head1 OPTIONS

=over 4

=item B<< --download >> (alias: B<-d>)

Download latest source data .zip files from the Unicode Consortium web site
and store in a local directory.

=item B<< --char <hex-num> >> (alias: B<-c>)

Instead of writing out a data file, dump the attributes of the specified
character on STDOUT.

=item B<--help> (alias: B<-?>)

Display this documentation.

=back

=cut

